## 挥手过程图

![[Pasted image 20230209091051.png]]

## 挥手过程说明
1. **第一次挥手**：客户端打算关闭连接，发送一个 `FIN 标志位` 为 1 的报文。叫做 `FIN 报文`。之后客户端从 `established` 阶段进入了 `fin_wait_1` 阶段。
2. **第二次挥手**：服务端接受到了 `FIN 报文` 后，向客户端发送 `ACK` 应答报文，进入了 `close_wait` 阶段。客户端收到了 `ACK 报文` 后，进入了 `fin_wait_2` 阶段。
3. **第三次挥手**：服务端处理完数据后，发送 `FIN` 报文，之后进入了 `LAST_ACK` 阶段。
5. **第四次挥手**：客户端收到了 `FIN 报文`，向服务端发送 `ACK 报文`，自身进入了 `time_wait` 阶段，经过了 `2 MSL`（报文最大生存时间）的时间，就彻底关闭了。服务端收到了 `ACK 报文`，也会关闭。

> 主动关闭连接的，才有 TIME_WAIT 状态。

### MSL 是什么，为什么要等待 2 MSL
`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。
可以看到 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。是为了保证一个来回可以完成。

`2MSL` 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**

在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。







