我们以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

```sql
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
```

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Redundant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9aab47ea5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

从图中可以看出来，对于`Compact`和`Redundant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9a5d5637a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

最后需要注意的是，不只是 _**VARCHAR(M)**_ 类型的列，其他的 _**TEXT**_、_**BLOB**_ 类型的列在存储数据非常多的时候也会发生`行溢出`。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

-   每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`132`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。
    
-   每个记录需要的额外信息是`27`字节。
    
    这27个字节包括下边这些部分：
    
    -   2个字节用于存储真实数据的长度
    -   1个字节用于存储列是否是NULL值
    -   5个字节大小的头信息
    -   6个字节的`row_id`列
    -   6个字节的`transaction_id`列
    -   7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，设计`MySQL`的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：

```scss
132 + 2×(27 + n) < 16384
```

求解这个式子得出的解是：`n < 8099`。也就是说如果一个列中存储的数据小于`8099`个字节，那么该列就不会成为`溢出列`，否则该列就需要成为`溢出列`。不过这个`8099`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为`溢出列`。