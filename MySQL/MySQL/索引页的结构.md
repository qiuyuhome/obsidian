# InnoDB 索引

## 行格式
以 MySQL 默认的 Dynamic 行格式为例：
```
变长字段长度列表 | Null值列表 | 记录头信息 | row_id | trans_id | roll_pointer | 列...
```

其中的 `记录头信息` 中，包含的信息如下：
![[Pasted image 20230207202554.png]]
所以，记录头信息中的 `next_record`，记录了下一条的记录信息。这就形成了一个**链表**。可以根据一条记录，直接找到下一条记录的位置。

## 索引页: index page


MySQL 中，页（page）是 InnoDB 管理空间的最小单位。一般大小为 16 KB。有很多不同类型的页。
用来存放记录的页是 **index page**。一般管它叫做 **索引页**。

结构如下：
![[Pasted image 20230207202842.png]]


其中的 file header、page header、page directory、file trailer 是大部分其他类型的页都会有的结构。

用户记录都会记录在 User Record 中，因此 Free Space 会越来越小。

其中 `最小记录和最大记录`。是 2 个隐藏的 记录。是必有的 2 条因此记录。

因此。结合 `行格式` 中的 `next_record`，就会形成了一个链表。

假设有 2 条用户记录。
`最小记录` 的 next_record，指向了用户的第一条记录，第一条记录的 next_record 指向了第二条用户记录，第二条用户记录的 next_record 指向了 `最大行记录`。

这里有一个细节。指向下一条记录的位置，不是行记录的起始位置，而是 next_record 标记的尾部，用户字段的前面。这样做的好处，就是往前找数据和往后找数据都很快。

为了更快速的定位到数据，MySQL 会给这些数据分组。规定：
- 对于最小记录所在的分组只能有 _**1**_ 条记录。
- 最大记录所在的分组拥有的记录条数只能在 _**1~8**_ 条之间。
- 剩下的分组中记录的条数范围只能在是 _**4~8**_ 条之间。

索引页（index page）的结构中，页面目录（page diretory）里面存放的是 **槽（slot）**,有几个组，就会有几个槽。槽里面存放的是每组中最大记录的偏移量。

这样，可以根据页面目录中的槽，快速的定位到每组中的最大记录。

这个时候，就可以通过 `二分法` 快速的定位记录了，如图：
![[Pasted image 20230207211036.png]]
比方说我们想找主键值为`6`的记录，过程是这样的：
1.  计算中间槽的位置：`(0+4)/2=2`，所以查看`槽2`对应记录的主键值为`8`，又因为`8 > 6`，所以设置`high=2`，`low`保持不变。
2.  重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`，又因为`4 < 6`，所以设置`low=1`，`high`保持不变。
3.  因为`high - low`的值为1，所以确定主键值为`6`的记录在`槽2`对应的组中。此刻我们需要找到`槽2`中主键值最小的那条记录，然后沿着单向链表遍历`槽2`中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里`槽2`对应的记录是主键值为`8`的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到`槽1`对应的记录（主键值为`4`），该条记录的下一条记录就是`槽2`中主键值最小的记录，该记录的主键值为`5`。所以我们可以从这条主键值为`5`的记录出发，遍历`槽2`中的各条记录，直到找到主键值为`6`的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。

所以在一个 index page 中查找指定主键值的记录的过程分为两步：
1.  通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2.  通过记录的`next_record`属性遍历该槽所在的组中的各个记录。


这样，就可以在一个 index page 中，快速的根据主键，定位到我们想要找的数据了。


页与页之间，其实也是一个链表，还是一个双向链表。利用到了页结构中的 `file header`。
file header 中有 2 个标志：FIL_PAGE_PREV 和 FIL_PAGE_NEXT。就形成了如下图的结构。

![[Pasted image 20230207211656.png]]

## 页分裂

假设有一个 index page 中的主键分别是 1、3、5，假设这个页已经装满了，现在要插入一条主键为 4 的记录，需要放在另一个 index page 中。InnoDB 要求下一个 index page 最小主键，必须大于上一个 index page 的最大主键，也就是说主键必须是递增的。这个时候就要移动数据，来保持这种规则，这个过程就是 **页分裂**。



## 目录项记录

InnoDB 为了快速的根据主键找到记录是在哪个 index page 中。是这么设计的。

专门用一个 index page 来存储记录，这些记录不是用户存储的数据，而是前面说的每个页中的页的 `页号` 和 `每页中的最小主键`。最小主键指向了对应的页，就形成了如下的结构：
![[Pasted image 20230207215943.png]]

这个就是 `目录项记录`，类似于字典中的目录。
如何区分是普通记录还是目录项记录呢？看看 `行格式` 中的 record_type 意义吧。

这样，就又可以通过 `二分查找` 快速的定位到数据在哪个 index page 中了。

数据越来越多，最后可能是这个样子的。
![[Pasted image 20230207220345.png]]

这个就是 InnoDB 的 **B+tree**。

B+tree 的层级是很低的。可以减少磁盘的 IO。
为什么会很低呢？
假设 index page 可以存储的用户记录是 100 个，页中存储的目录项记录是 1000 个。
2 层结构，可以存储 100 * 1000 = 100000，是 10W 个。
3 层结构，可以存储 100 * 1000 * 1000 = 100000000，是 1 亿个。
4 层结构，可以存储 100 * 1000 * 1000 * 1000 = 100000000，是 1000 亿个。

## 根节点

B+tree 最顶层的就是根节点，每当为某个表创建一个`B+`树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个`根节点`页面。

个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的`根节点`的页号便会被记录到某个地方，然后凡是`InnoDB`存储引擎需要用到这个索引的时候，都会从那个固定的地方取出`根节点`的页号，从而来访问这个索引。

根节点的地址保存在了数据字典中。

## 二级索引（普通索引）

普通索引的结构也类似，也是一个 B+tree。

这个`B+tree`与上边介绍的聚簇索引有几处不同：

-   使用记录`c2`列的大小进行记录和页的排序，这包括三个方面的含义：
    
    -   页内的记录是按照`c2`列的大小顺序排成一个单向链表。
        
    -   各个存放用户记录的页也是根据页中记录的`c2`列大小顺序排成一个双向链表。
        
    -   存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的`c2`列大小顺序排成一个双向链表。
        
-   `B+`树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值。
    
-   目录项记录中不再是`主键+页号`的搭配，而变成了`c2列+页号`的搭配。


对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：
-   索引列的值
-   主键值
-   页号
这样因为有主键，就可以保证是唯一的，新插入的数据，就可以定位到自己的位置了。

如图：
![[Pasted image 20230207222158.png]]


# MyISAM 索引

MyISAM 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。
由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。
使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。`MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录。

# 讲解思路

可以先将一下整体的 B+tree 的结构。聚簇索引是什么样的，
1. 叶子节点才会存放真正的数据。
2. 数据都是存储在 index page 中的。这里就可以将 index page 是如何形成的双向链表。
3. 再讲一下行格式，是如何形成的单向链表。
这样整体的 B+tree 的结构大体就都讲到了。


