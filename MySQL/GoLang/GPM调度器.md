[GO GMP协程调度实现原理 5w字长文史上最全 - 木的树 - 博客园](https://www.cnblogs.com/dojo-lzz/p/16342622.html)


GMP 是目前 Go 使用的调度模型。

## GMP 概念
### G
G 是 gorouting，每次`go func`都代表一个G。
### M
M 是 工作线程或者 machine，可以理解为线程。
比P多，M的最大数量可以进行设置，这个初始值是10000。
### P
P 是 processor，处理器，执行Go代码所需的资源。
M必须有一个关联的P来执行Go代码。个数是 gomaxprocs 决定的。

## 存放 G 的队列

### 本地队列
每个 P 都有自己的本地队列。存放数量上限**256**个。新建G时，`G优先加入到P的本地队列，如果队列满了，则会把本地队列中的一半G移动到全局队列`

### 全局队列
还有一个全局队列。存放等待运行G。这个全局队列，使用互斥锁来保护，每次有 P 从全局队列获取 G，都需要加锁。

全局队列中的G不会饥饿，P中每执行61次调度，就需要优先从全局队列中获取一个G到当前P中，并执行下一个要执行的G。

简单的来说，一个G的执行需要M和P的支持。一个M在与一个P关联之后形成了一个有效的G运行环境【内核线程 + 上下文环境】。每个P都会包含一个可运行的G的队列 (runq )。


## 调度策略
**调度器核心思想**是尽可能避免频繁的创建、销毁线程，对线程进行复用以提高效率。

所以 go 使用了 work stealing 机制和 hand off 机制。

### work stealing（偷取）
当 M 绑定的 P，本地队列中空了，会从全局队列获取，全局队列没有，则会从其他的 P 的本地队列中偷取 G。而不是直接销毁线程。

### hand off 机制
当 M1 绑定的 P1, 因为 G1 进行的系统调用阻塞时，P1 会断开 M1，让 G1 单独的与 M1 关联在一起阻塞着，P1 会转移到其他的空闲的 M 上。

## 抢占
一个goroutine最多占用CPU **10ms**，防止其他goroutine等待太久得不到执行被“饿死”。

## 优势
- goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；
- goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。

  