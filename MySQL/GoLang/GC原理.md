## 概念
GC，垃圾回收机制，指的是，当我们在程序中定义一个变量，是需要开辟内存空间进行存储的，当不再需要此变量了，需要销毁此对象，回收释放的内存，这种对不再使用的内存资源进行回收的功能，就是**垃圾回收（Garbage Collection，缩写为GC）**


## 常见的 GC 类型

### 引用计数算法(reference counting)
引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象，这种算法在内存比较紧张和实时性比较高的系统中使用比较广泛，如php，Python等。

**优点：**
1. 方式简单，回收速度快。
**缺点：**
1. 需要额外的空间存放计数。
2. 无法处理循环引用(如a.b=b; b.a=a)。
3. 频繁更新引用计数降低了性能。

### 追踪式回收算法(Tracing)
追踪式算法(可达性分析)的核心思想是判断一个对象是否可达，如果这个对象一旦不可达就可以立刻被GC回收了，那么我们怎么判断一个对象是否可达呢？第一步从根节点开始找出所有的全局变量和当前函数栈里的变量，标记为可达。第二部，从已经标记的数据开始，进一步标记它们可访问的变量，以此类推，专业术语叫传递闭包。当追踪结束时，没有被打上标记的对象就被判定是不可触达。

**优点：**
1. 解决了循环引用的问题
2. 占用的空间少了
和引用计数法相比，有以下**缺点**：
1. 无法立刻识别出垃圾对象，需要依赖GC线程
2. 算法在标记时必须暂停整个程序，即**STW(stop the world)**，否则其他线程有可能会修改对象的状态从而回收不该回收的对象
Go使用的三色标记法，也属于追踪式回收算法的一个变种。

## go 的 GC

### V1.3 之前 - 标记清除算法(Mark Sweep)
go v1.3 之前，使用的就是标记清除(mark and sweep)。

#### 流程
1. 第⼀步，暂停程序业务逻辑, 找出不可达的对象，和可达对象。
2. 第⼆步, 开始标记，程序找出它所有可达的对象，并做上标记。
3. 第三步, 标记完了之后，然后开始清除未标记的对象.
4. 第四步, 停⽌暂停，让程序继续跑。然后循环重复这个过程，直到process程序⽣命周期结束。

此算法主要有两个步骤：
- 暂停应用程序的执行, 从根对象出发标记出可达对象。
- 清除未标记的对象，恢复应用程序的执行。

#### 缺点
- STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。
- 标记需要扫描整个heap
- 清除数据会产⽣heap碎⽚

这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步地进行垃圾回收，对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题。

### Go V1.5 三⾊标记法
#### 概念
Go语言现在用的三色标记法就属于追踪式垃圾回收算法的一种。

三色标记算法将程序中的对象分成白色、黑色和灰色三类：
- 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
- 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象，垃圾回收器不会扫描这些对象的子对象；
- 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

#### 根对象
这里所说的根节点集合里的根对象就是栈上的对象或者堆上的全局变量。
根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：
1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

#### 基本思想
1. 第⼀步，就是只要是新创建的对象, 默认的颜⾊都是标记为“⽩⾊”。
2. 第⼆步，每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从⽩⾊集合放⼊“灰⾊”集合。
3. 第三步，遍历灰⾊集合，将灰⾊对象引⽤的对象从⽩⾊集合放⼊灰⾊集合，之后将此灰⾊对象放⼊⿊⾊集合。
4. 第四步，重复第三步, 直到灰⾊中⽆任何对象。
5. 第五步，回收所有的⽩⾊标记表的对象，也就是回收垃圾。

#### 对象丢失现象
如果三⾊标记法不被STW保护
条件1: ⼀个⽩⾊对象被⿊⾊对象引⽤ (⽩⾊被挂在⿊⾊下)
条件2: 灰⾊对象与它之间的可达关系的⽩⾊对象遭到破坏 (灰⾊同时丢了该⽩⾊)

两个条件同时满⾜，那么就会出现对象丢失的现象。

go 通过 **强弱三⾊不变式** 的原理，来解决这种问题。

#### 强弱三⾊不变式
这是一个总结的规律。
**强三⾊不变式**：不允许黑色对象引用白色对象。
**弱三⾊不变式**：黑色对象可以引用白色对象，前提是这个白色对象存在其他灰色对象对它的引用，或者可触达这个白色对象的路径上存在灰色对象。

如果三⾊标记满⾜强弱不变式之⼀，即可保证不丢失对象。

#### 屏障机制
##### 插⼊屏障
这种机制，就是为了避免对象丢失，要满足强弱三色不变式而设计的一种机制。

**对象被引⽤时触发的机制**：
具体操作: 在A对象引⽤B对象的时候，B 对象被标记为灰⾊。(将B挂在A下游，B必须被标记为灰⾊)
满⾜: 强三⾊不变式. (不存在⿊⾊对象引⽤⽩⾊对象的情况了，因为⽩⾊会强制变成灰⾊)

**不足**：结束时需要STW来重新扫描栈，⼤约需要10~100ms

##### 删除屏障
****
**对象被删除时触发的机制**
具体操作: 被删除的对象，如果⾃身为灰⾊或者⽩⾊，那么被标记为灰⾊。
满⾜: 弱三⾊不变式. (保护灰⾊对象到⽩⾊对象的路径不会断)

**不足**：回收精度低，⼀个对象即使被删除了最后⼀个指向它的指针也依旧可以活过这⼀轮，在下⼀轮GC中被清理掉。

### Go V1.8 混合写屏障机制
1.8 版本，还是用的上面的三色标记法，但使用了**混合写屏障机制**。

#### 具体操作
1、GC开始，将栈上的对象全部扫描并标记为⿊⾊(之后不再进⾏第⼆次重复扫描，⽆需STW)。
2、GC期间，任何在栈上创建的新对象，均为⿊⾊。
3、被删除的对象标记为灰⾊。
4、被添加的对象标记为灰⾊。
> 满⾜: 变形的弱三⾊不变式. (结合了插⼊、删除写屏障两者的优点)

