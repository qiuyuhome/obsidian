[Go 逃逸分析 | Go 语言高性能编程 | 极客兔兔](https://geektutu.com/post/hpg-escape-analysis.html)

## 1. 定义
Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？编译器决定内存分配位置的方式，就称之为**逃逸分析(escape analysis)**。逃逸分析由**编译器完成**，作用于**编译阶段**。

## 为什么需要逃逸分析这个功能呢？
函数中申请一个新的对象：
- 如果分配在栈中，则函数执行结束可自动将内存回收；
- 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；

逃逸分析的好处应该是减少了 gc 的压力，栈的分配比堆快，性能好，如果变量都分配到栈上，可以避免 Go 频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。

在golang中每个协程都维护自己的栈空间,初始大小为2KB，最大为1GB。而每个协程的堆大小也是有限制的，在64位操作系统下是1GB，32位操作系统下是250MB,超出时会panic。

逃逸分析的作用，主要是因为堆（heap）相对于栈（stack）来说大很多，而且栈是由每个协程独立战友的，而堆是共有的。栈是后进先出，在一个 function 运行完毕以后，里面的局部变量就会退出。栈有 2 个操作，一个是push，一个是 pop。运行是很快的。
而堆则是



## 2. 如何分析是否逃逸

### 2.1 命令 
编译时可以借助选项 `-gcflags=-m`，查看变量逃逸的情况。-m打印逃逸分析信息，-l禁止内联编译。如：`go build -gcflags=-m main.go`

### 2.2 goland 中的配置
在 goland 中，是这么设置的：
![[Pasted image 20230203092627.png]]

![[Pasted image 20230203092715.png]]

`new(Demo) escapes to heap` 即表示 `new(Demo)` 逃逸到堆上了。


## 3. 逃逸分析的几种情况

### 3.1 指针逃逸
### 3.2 栈空间不足逃逸
### 3.3 函数参数为 interface{}
### 3.4 闭包引用对象逃逸

## 总结

- 栈上分配内存比在堆中分配内存效率更高
- 栈上分配的内存不需要 GC 处理，而堆需要
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成

## 如何利用逃逸分析提升性能
传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。

