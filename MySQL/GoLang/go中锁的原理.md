# Mutex 互斥锁

[Go 为什么不支持可重入锁？ - 掘金](https://juejin.cn/post/7043326180577476644)
[02 | Mutex：庖丁解牛看实现](https://time.geekbang.org/column/article/295850)
[2.4 mutex · GitBook](https://books.studygolang.com/GoExpertProgramming/chapter02/2.4-mutex.html)
[2.5 rwmutex · GitBook](https://books.studygolang.com/GoExpertProgramming/chapter02/2.5-rwmutex.html)
[【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？ - 编程迷思 - 博客园](https://www.cnblogs.com/kismetv/p/10787228.html)

## CAS 
### 概念
cas 是一个原子操作。在 go 中，在 atomic 包下，以 atomic.CompareAndSwapInt32() 为例：
有 3 个参数，
第一个参数：是一个指针，就是要操作的数的指针，&i。
第二个参数：是 old，意思原来的值。
第三个参数：是 new，意思是要使用的新的值。
返回 bool

```go
atomic.CompareAndSwapInt32(&i, 1, 3)
```

意思是，要把 i 的值从1 变为 3。如果在执行期间，有其他的协程改变了 i 的值，那么，会发现第二个参数的值不是1，则返回false，如果发现第二个参数的值是预期的 1，则就把它变为 3。返回 true。

在 mutex 中，是依赖于 CAS 的。

## Mutex 简介

### 结构体
Mutex 是一个结构体，对外提供了 Lock() 和 Unlock() 2 个方法。分别用来加锁和解锁。

```go
   type Mutex struct {
        state int32
        sema  uint32
    }
    
    const (
        mutexLocked = 1 << iota 
        mutexWoken              
        mutexStarving           
        mutexWaiterShift = iota
    
        starvationThresholdNs = 1e6
    )
```

- Mutex 是一个互斥锁，其零值对应了未上锁的状态，不能被拷贝；
- state 代表互斥锁的状态，比如是否被锁定；
- sema 表示信号量，协程阻塞会等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。

注意到 state 是一个 int32 变量，内部实现时把该变量分成四份，用于记录 Mutex 的状态

![[Pasted image 20230206151002.png]]


- Locked: 表示该 Mutex 是否已经被锁定，0表示没有锁定，1表示已经被锁定；
- Woken: 表示是否有协程已经被唤醒，0表示没有协程唤醒，1表示已经有协程唤醒，正在加锁过程中；
- Starving: 表示该 Mutex 是否处于饥饿状态，0表示没有饥饿，1表示饥饿状态，说明有协程阻塞了超过1ms；
- Waiter 信息虽然也存在 state 中，其实并不代表状态。它表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。

协程之间的抢锁，实际上争抢给`Locked`赋值的权利，能给 `Locked` 置为1，就说明抢锁成功。抢不到就阻塞等待 `sema` 信号量，一旦持有锁的协程解锁，那么等待的协程会依次被唤醒。
在 go 中给 Locked 赋值，都是使用的上面介绍的 CAS 原子操作。

`Woken` 和 `Starving` 主要用于控制协程间的抢锁过程。

### 原理简介
假设协程 A 已经获取到了锁。目前没有其他协程要获取锁。则此时的 state 值为：

```
waiter   starving   woken   locked
   0       0         0       1
```

协程 B 要获取锁，被阻塞，则 Mutex 的状态变为：
```
waiter   starving   woken   locked
   1       0         0       1
```
Waiter 计数器增加了1，协程B将会持续阻塞。

然后协程 A 解锁，会把 Locked 标志位变为 0，然后判断 Waiter 是否大于0，大于0代表有协程在阻塞等待着，就会释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程把 `Locked` 置为1，获取到锁。

在这期间，有几个重要的设计理念：自旋和饥饿模式。


## 自旋
### 自旋的概念
加锁时，如果当前 `Locked` 位为1，则说明当前该锁由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续探测 `Locked` 位是否变为0，这个过程就是「**自旋**」。

自旋的时间很短，如果在自旋过程中发现锁已经被释放，那么协程可以立即获取锁。此时即便有协程被唤醒，也无法获取锁，只能再次阻塞。

自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免一部分协程的切换。

自旋对应于 CPU 的 `PAUSE` 指令，CPU 对该指令什么都不做，相当于空转。对程序而言相当于`sleep`了很小一段时间，大概 30个时钟周期。连续两次探测`Locked` 位的间隔就是在执行这些 `PAUSE` 指令，它不同于`sleep`，不需要将协程转为睡眠态。

### 自旋条件

加锁时 Golang 的 runtime 会自动判断是否可以自旋，无限制的自旋将给 CPU 带来巨大压力，自旋必须满足以下所有条件：

-   自旋次数要足够少，通常为 4，即自旋最多 4 次；
-   CPU 核数要大于 1，否则自旋没有意义，因为此时不可能有其他协程释放锁；
-   协程调度机制中的 P 的数量要大于 1，比如使用 `GOMAXPROCS()` 将处理器设置为 1 就不能启用自旋；
-   协程调度机制中的可运行队列必须为空，否则会延迟协程调度。

可见自旋的条件是很苛刻的，简单说就是不忙的时候才会启用自旋。

### 自旋的优势

自旋的优势是更充分地利用 CPU，尽量避免协程切换。因为当前申请加锁的协程拥有 CPU，如果经过短时间的自旋可以获得锁，则当前写成可以继续运行，不必进入阻塞状态。
  
### 自旋的问题

如果在自旋过程中获得锁，那么之前被阻塞的协程就无法获得。如果加锁的协程特别多，每次都通过自旋获取锁，则之前被阻塞的协程将很难获取锁，从而进入【**饥饿状态**】。

为此，Golang 1.8 版本后为`Mutex`增加了`Starving`模式，在这个状态下不会自旋，一旦有协程释放锁。那么一定会唤醒一个协程并成功加锁。

## Mutex 的模式

每个 Mutex 都有两种模式：**Normal**, **Starving**。

### Normal 模式

默认情况下的模式就是 Normal。 在该模式下，协程如果加锁不成功，不会立即转入阻塞排队（先进先出），而是判断是否满足自旋条件，如果满足则会启动自旋过程，尝试抢锁。

### Starving 模式

自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁。我们知道释放锁时，如果发现有阻塞等待的协程，那么还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到 CPU 后开始运行，此时发现锁已经被抢占了，自己只好再次阻塞，不过阻塞前会判断，自上次阻塞到本次阻塞经过了多长时间，如果超过 1ms，则会将 Mutex 标记为 `Starving`模式，然后阻塞。

在`Starving`模式下，不会启动自旋过程，一旦有协程释放了锁，一定会唤醒协程，被唤醒的协程将成功获取锁，同时会把等待计数减 1。

如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:  
1. 此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；
2. 此 waiter 的等待时间小于 1 毫秒。

## Woken 状态

Woken 状态用于加锁和解锁过程中的通信。比如，同一时刻，两个协程一个在抢锁，一个在解锁，在抢锁的协程可能在自旋过程中，此时把 Woken 标记为 1，用于通知解锁协程不必释放信号量，类似知会一下对方，不用释放了，我马上就拿到锁了。
看源码，这里就是把自旋的协程，也给伪装成了唤醒的协程。

## 使用 mutex 的注意事项

- copy 的结构体中包含了锁，可能导致非预期的死锁
- 不是 `可重入锁`，因此同一个协程不可以多次调用 Lock()。会 panic。
- 一个goroutine中若是在调用Lock（）之前调用了unlock（），那么会panic。


# RWMutex 读写锁

## 应用场景
适用于读多写少的场景，当符合 read - write 的场景，且是读多写少，则可以考虑使用 RWMutex。

多个读操作可以同时持有锁，并发能力将大大提升。

## 数据结构
### 结构体
```go
type RWMutex struct {
    w           Mutex  //用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此
    writerSem   uint32 //写阻塞等待的信号量，最后一个读者释放锁时会释放信号量
    readerSem   uint32 //读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量
    readerCount int32  //记录读者个数
    readerWait  int32  //记录写阻塞时读者个数
}
```

### 实现原理

读和读是允许并发的。

如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。

#### RLock()
读锁定需要做两件事：
- 增加读操作计数，即readerCount++
- 阻塞等待写操作结束(如果有的话)：如果此时是有写锁定的话，则需要阻塞，等待写锁释放。写锁释放的时候，会唤醒所有的读。

#### RUnlock()
解除读锁定需要做两件事：
- 减少读操作计数，即readerCount--
- 如果 readWaiter - 1 后的结果是 0，唤醒等待写操作的协程（如果有的话）。

即便有协程阻塞等待写操作，并不是所有的解除读锁定操作都会唤醒该协程，而是最后一个解除读锁定的协程才会释放信号量将该协程唤醒，因为只有当所有读操作的协程释放锁后才可以唤醒协程。

#### Lock()
写锁定操作需要做两件事：
- 获取互斥锁：多个写锁定操作在此排队。
- 阻塞等待所有读操作结束（如果有的话）。
#### Unlock()
解除写锁定要做两件事：
- 唤醒因读锁定而被阻塞的协程（如果有的话）
- 解除互斥锁。

### 设计理念
#### readerCount 的反转
readerCount 在源码中，会有 2 中含义。
在 Lock() 时，为负数，`r := atomic.AddInt32(&rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders`。
后续会判断 rw.readerCount 的值是否是负数，如果为负数，则意味着此时有writer等待请求锁。

在 Unlock() 时，会 `r := atomic.AddInt32(&rw.readerCount, rwmutexMaxReaders)`。
把 rw.readerCount 再转换为正数，告诉reader没有活跃的writer了。


#### 如何避免写锁不会被饿死
写操作要等待读操作结束后才可以获得锁，写操作等待期间可能还有新的读操作持续到来，如果写操作等待所有读操作结束，很可能被饿死。然而，通过RWMutex.readerWait可完美解决这个问题。

写操作到来时，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记排在写操作前面的读者个数。

前面的读操作结束后，除了会递减RWMutex.readerCount，还会递减RWMutex.readerWait值，当RWMutex.readerWait值变为0时唤醒写操作。

所以以，写操作就相当于把一段连续的读操作划分成两部分，前面的读操作结束后唤醒写操作，写操作结束后唤醒后面的读操作。
